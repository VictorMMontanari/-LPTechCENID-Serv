
var cuid = require('shortid')
var flatten = require('flat')
var values = require('lodash.values')
var typeOf = require('component-type')
var Emitter = require('component-emitter')
var Datatype = require('./datatype')

/**
 * Expose `NormalizedDatabase`.
 */

module.exports = NormalizedDatabase

/**
 * Initialize a new database.
 */

function NormalizedDatabase() {
  this.state = new Datatype('State')
  this.models = {}
  this.state.isUserland = true
  this.diffs = []
  this.model('State')
  Emitter.call(this)
  this.on('invalidate', this.denormalize.bind(this))
  this.on('change', this.onchange.bind(this))
  this.on('diff path', this.ondiffpath.bind(this))
}

/**
 * Make this an `Emitter`.
 */

Emitter(NormalizedDatabase.prototype)

/**
 * Define a model.
 *
 * model('Plane', 'Plane[id]')
 */

NormalizedDatabase.prototype.model = function(model, collection){
  if (this.models[model]) return
  var dt = collection ? this.datatype(collection) : this.state
  var schema = this.models[model] = {
    type: model,
    fields: {},
    collection: dt
  }
  if (collection && !dt.idProperty) throw new Error('Collection must have an ID property, try ' + collection + '[id]')
  if (dt.idProperty) schema.fields[dt.idProperty] = 'Single line text'
  if (collection) {
    this.models.State.fields[collection] = model
  }
  dt.model = schema
  var aliases = dt.aliases
  for (var id in aliases) {
    var alias = aliases[id]
    alias.model = schema
  }
}

/**
 * Define a model field.
 */

NormalizedDatabase.prototype.field = function(field, type) {
  var fragments = field.split('/')
  var model = fragments.shift()
  var field = fragments.join('/')
  this.model(model, model + '[id]')
  this.models[model].fields[field] = type
  if (model == 'State') {
    var dtf = this.datatype(field)
    dtf.model = this.models[type]
  } else {

  }
}

NormalizedDatabase.prototype.ondiffpath = function(diff) {
  this.diffs.push(diff)
  if (this.resolving) return
  this.resolving = setTimeout(this.resolve.bind(this), 1)
}

/**
 * Denormalize it.
 */

NormalizedDatabase.prototype.resolve = function() {
  var diffs = this.diffs
  this.diffs = []
  this.resolving = undefined
  // collections[model].changed
  // collections[model].added
  // collections[model].removed
  // [recordId] = { property: value }
  var collections = {}
  var records = {}
  for (var i = 0, n = diffs.length; i < n; i++) {
    var diff = diffs[i]
    var path = this.findPath(diff.path)
    var fragments = path.split('/')
    var collection = fragments.shift()
    if (collection == 'State') {
      var model = this.models.State
      var field = fragments.join('/')
      var type = model.fields[field]
      var record = collections[collection] = collections[collection] || {}
      if (type && this.models[type]) {
        var childModel = this.models[type]
        var collection = childModel.collection
        var idProperty = collection.idProperty
        record[field] = {}
        record[field][idProperty] = diff.value[idProperty]
      } else {
        record[field] = diff.value
      }
    } else {
      var model = this.state.children[collection].model
      var id = fragments.shift()
      var field = fragments.join('/')
      if (!field) continue
      var records = collections[model.type] = collections[model.type] || {}
      var record = records[id] = records[id] || {}
      var type = model.fields[field]
      if (type && this.models[type]) {
        var childModel = this.models[type]
        var collection = childModel.collection
        var idProperty = collection.idProperty
        if (Array.isArray(diff.value)) {
          // Only return the `id` because we know we got the value already.
          record[field] = diff.value.map(function(item){
            var obj = {}
            obj[idProperty] = item[idProperty]
            return obj
          })
        } else {
          record[field] = {}
          record[field][idProperty] = diff.value[idProperty]
        }
      } else {
        record[field] = diff.value
      }
    }
  }
  this.emit('diff', collections)
}

NormalizedDatabase.prototype.findPath = function(path) {
  var model = this.models.State
  var fragments = path.split('/')
  var finalFragments = ['State']
  var i = 0
  var start = 0
  var n = fragments.length
  var dt
  var collection
  var pdt
  while (i < n) {
    var fragment = fragments[i]
    var fullPath = fragments.slice(0, i + 1).join('/')
    var partialPath = fragments.slice(start, i + 1).join('/')
    var type = model.fields[partialPath]
    var isModel = type && this.models[type]
    dt = this.datatype(fullPath)
    if (isModel) {
      model = this.models[type]
      collection = model.collection
      start = i + 1
      // Plane[id]
      if (collection == dt) {
        // start over
        finalFragments = [ partialPath ]
      } else {
        if (i + 1 < n && dt.isArray) {
          // dt = collection
          finalFragments = [ collection.property ]
        } else if (dt.isArray) {
          finalFragments.push(fragment)
        } else if (i + 1 < n) {
          var id = this.get(fullPath + '/id')
          finalFragments = [ collection.property, id ]
          start = i + 2
          dt = this.datatype(fullPath)
        } else {
          finalFragments.push(partialPath)
        }
      }
      // next model down
    } else if (pdt) {
      // nested array
      if (pdt.children[fragment]) {
        if (pdt.isArray) {
          // Plane[id]/1/children[] the children[] property points to models
          if (model.fields[pdt.property]) {
            var type = model.fields[pdt.property]
            model = this.models[type]
            collection = model.collection
            var id = this.get(fullPath + '/id')
            start = i + 1
            finalFragments = [ collection.property, id ]
            dt = this.datatype(fullPath)
          } else {
            var id = this.get(fullPath + '/id')
            dt = this.datatype(fullPath)
            finalFragments.push(id)
            start = i + 1
          }
        } else {
          finalFragments.push(fragment)
          start = i + 1
          dt = this.datatype(fullPath)
        }
      } else {
        finalFragments.push(fragment)
        dt = this.datatype(fullPath)
      }
    } else {
      finalFragments.push(fragment)
    }
    pdt = dt
    i++
  }
  return finalFragments.join('/')
}

NormalizedDatabase.prototype.onchange = function(change) {
  var path = change[0]
  var before = change[1]
  var after = change[2]
  if (before == null && after != null) {
    this.emit('diff path', {
      type: 'add',
      path: path,
      value: after
    })
  } else if (before != null && after == null) {
    this.emit('diff path', {
      type: 'remove',
      path: path,
      value: before
    })
  } else if (before != after) {
    this.emit('diff path', {
      type: 'change',
      path: path,
      value: after
    })
  }
}

/**
 * This denormalizes the data based on the model definitions.
 *
 * It then emits an event with the diff of the data changed in the models,
 * so a database can then store them.
 */

NormalizedDatabase.prototype.denormalize = function(paths) {
  for (var i = 0, n = paths.length; i < n; i++) {
    var model = this.models.State
    var path = paths[i]
    var fragments = path.split('/')
    var start = 0
    var x = 0
    var y = fragments.length
    while (x < y) {
      var fullPath = fragments.slice(0, x + 1).join('/')
      var partialPath = fragments.slice(start, x + 1).join('/')
      var type = model.fields[partialPath]
      if (type && this.models[type]) {
        model = this.models[type]
        var source = this.datatype(fullPath)
        start = i
        if (source == model.collection) continue
        var collection = model.collection
        var idProperty = collection.idProperty
        if (source.isArray) {
          var els = this.get(fullPath)
          for (var j = 0, m = els.length; j < m; j++) {
            var el = els[j]
            var id = el[idProperty]
            this.equivalent(collection.property + '/' + id, fullPath + '/' + j)
          }
          x++
          start++
        } else {
          var id = this.get(fullPath + '/' + idProperty)
          if (id) {
            this.equivalent(collection.property + '/' + id, fullPath)
          }
        }
        // if (dt.model.collection == dt) continue
      }
      x++
    }
  }
}

NormalizedDatabase.prototype.schema = function(type){
  return this.datatype(type).schema()
}

NormalizedDatabase.prototype.canonical = function(typeA) {
  // Should rewrite them if canonical is specified.
  var dt = this.datatype(typeA)
  dt.isCanonical = true
  for (var id in dt.aliases) {
    var alias = dt.aliases[id]
    alias.isCanonical = false
  }
}

/**
 * Makes an alias between two types, so they are the exact same shared state.
 */

NormalizedDatabase.prototype.equivalent = function(typeA, typeB) {
  var dta = this.datatype(typeA)
  var dtb = this.datatype(typeB)
  dta.alias(dtb)
  dtb.alias(dta)
  this.canonical(typeA)
}

/**
 * Basically turns this into a normalized database, so
 * it doesn't store all the types in a big tree, but multiple small trees.
 *
 * Not sure how this would work.
 *
 * In this case, the canonical version is an item in an array.
 *
 * So to find the canonical, it gets the dta and then searches the children by id.
 */

NormalizedDatabase.prototype.instanceof = function(type, element) {
  var model = this.models[type]
  var dta = model ? model.collection : this.datatype(type)
  var dtb = this.datatype(element)
  var el = this.get(element)
  if (!el) throw new Error('Property is not defined: ' + element)
  var id = el[dta.idProperty]
  var nestedpath = type + '/' + id
  this.equivalent(nestedpath, element)
  dtb.instanceofs[dta.id] = dta
}

/**
 * In this case, the records id of one collection points to the other collection.
 *
 * The elements are all instanceof the type.
 */

NormalizedDatabase.prototype.subsetof = function(type, element) {
  // this.set(type, this.get(element))
  var dta = this.datatype(type)
  var dtb = this.datatype(element)
  var els = this.get(element)
  dtb.subsetofs[dta.id] = dta
  for (var i = 0, n = els.length; i < n; i++) {
    var el = els[i]
    var id = dta.idProperty ? el[dta.idProperty] : i
    var nestedpath = type + '/' + id
    var id = dtb.idProperty ? el[dtb.idProperty] : i
    var nestedelement = element + '/' + id
    this.equivalent(nestedpath, nestedelement)
  }
  var pattern = new RegExp('^' + element.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '\/([^\/]+)$')
  this.on('invalidate', function(paths){
    for (var i = 0, n = paths.length; i < n; i++) {
      var path = paths[i]
      if (path.match(pattern)) {
        var id = RegExp.$1
        var nestedelement = element + '/' + id
        this.instanceof(type, nestedelement)
        if (dtb.idProperty) {
          var nestedpath = type + '/' + id
        } else if (dta.idProperty) {
          var id = this.get(nestedelement)[dta.idProperty]
          var nestedpath = type + '/' + id
        } else {
          var nestedpath = type + '/' + id
        }
        this.equivalent(nestedpath, nestedelement)
      }
    }
  }.bind(this))
}

/**
 * Find all child types.
 *
 * Given ['Userland'], it would print all of the types.
 */

NormalizedDatabase.prototype.types = function(path){
  return this.datatype(path).affectivePaths()
}

// /Planes/{id}/style/background
//   Becomes:
// /Planes/{id}/style -> id
// /Planes.style/{id}/background -> id
// /Planes.style.background/{id} -> value
//
// /Settings/title
//   Becomes:
// /Settings/{title id}
// /Settings.title -> value
//

NormalizedDatabase.prototype.get = function(path) {
  var datatype = this.datatype(path)
  var value = this.hydrate(datatype.canonical())
  if (datatype.isArray) {
    value = values(value)
  }
  return value
}

/**
 * 1. Create all typealiases and datatypes.
 * 2. Resolve aliases.
 * 3. Set datatype value.
 */

NormalizedDatabase.prototype.set = function(path, value) {
  var pdtpath = path.split('/')
  pdtpath.pop()
  pdtpath = pdtpath.join('/')
  var pdt = pdtpath && this.datatype(pdtpath)
  var dt = this.datatype(path)
  var originalValue = this.get(path)
  var changes = [ path, originalValue, value ]
  var invalidationtype = path

  // Set an actual value.
  if (dt.isArray) {
    var self = this
    // Get the correct index in the array to append to.
    var length = this.get(path).length
    for (var i = 0, n = value.length; i < n; i++) {
      var index = i
      var item = value[i]
      var key = dt.idProperty ? item[dt.idProperty] : String(index + length)
      var nestedpath = path + '/' + key
      this.set(nestedpath, item)
    }
  } else {
    if (value && typeOf(value) == 'object') {
      // Flatten the keys
      var flattened = flatten(value, { delimiter: '/', safe: true })
      for (var key in flattened) {
        var nestedpath = path + '/' + key
        var value = flattened[key]
        if (Array.isArray(value)) nestedpath += '[]'
        this.set(nestedpath, value)
      }
    } else {
      if (value === undefined) {
        // Clean up all the alias references.
        if (pdt && pdt.children[dt.property]) {
          delete pdt.children[dt.property]
          invalidationtype = pdtpath
        }
        for (var id in dt.aliases) {
          var alias = dt.aliases[id]
          for (var p in alias.parents) {
            var palias = alias.parents[p]
            if (palias.children[alias.property]) {
              delete palias.children[alias.property]
            }
          }
        }
      } else {
        dt.set(value)
      }
    }
  }

  // Emit, only if changed.
  if (changes[1] !== changes[2]) {
    this.emit('invalidate', this.types(invalidationtype).sort())
    this.emit('change', changes)
  }
}

/**
 * Expand out the data structure.
 */

NormalizedDatabase.prototype.hydrate = function(canonical) {
  if (canonical.isPrimitive) return canonical.value
  if (canonical.isArray) {
    var array = []
    var children = canonical.children
    for (var key in canonical.children) {
      var child = canonical.children[key]
      var value = this.hydrate(child.canonical())
      if (value != null) array.push(value)
    }
    return array
  }
  var object = {}
  var hasChildren = false
  for (var key in canonical.children) {
    hasChildren = true
    var child = canonical.children[key]
    var value = this.hydrate(child.canonical())
    object[child.exportProperty] = value
  }
  return hasChildren ? object : null
}

/**
 * Define all the nested types for a path.
 *
 * Userland.Planes.collection[] would make
 *   Userland
 *   Userland.Planes
 *   Userland.Planes.collection[]
 *
 * And they would all be canonical.
 *
 * Then if you do `canonical('Plane')`, canonical types would be
 *
 * Plane
 * Userland
 * Userland.Planes
 *
 * And so if a path was created like
 *
 * Userland.Planes.collection[].0.container
 *
 * It would not become a canonical path, it would become:
 *
 * Userland.Plane.0.container
 */

NormalizedDatabase.prototype.datatype = function(type) {
  var datatype = this.state
  var model = datatype.model
  var fragments = type.split('/')
  for (var i = 0, n = fragments.length; i < n; i++) {
    var fragment = fragments[i]
    // fragment == plane
    var childdatatype = datatype.children[fragment]
    if (!childdatatype) {
      childdatatype = new Datatype(fragment)
    }
    datatype.child(childdatatype)
    datatype = childdatatype
  }
  return datatype
}

NormalizedDatabase.prototype.toJSON = function(){
  return this.state.toJSON()
}
