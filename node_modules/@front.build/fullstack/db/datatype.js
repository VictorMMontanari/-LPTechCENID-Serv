
var cuid = require('shortid')
var flatten = require('flat')

module.exports = Datatype

/**
 * User-specified types.
 */

function Datatype(property) {
  this.id = cuid()
  this.property = property
  this.isArray = !!property.match(/\[([^\]]*)\]$/)
  if (this.isArray) this.idProperty = RegExp.$1
  this.exportProperty = this.isArray ? property.replace(/\[[^\]]*\]$/, '') : property
  this.aliases = {}
  this.children = {}
  this.parents = {}
  this.instanceofs = {}
  this.subsetofs = {}
  this.value = null
  this.isPrimitive = false
}

/**
 * Creates shared state between all the aliases.
 */

Datatype.prototype.alias = function(datatype){
  this.aliases[datatype.id] = datatype

  var sharedChildren = {}
  for (var name in datatype.children) {
    sharedChildren[name] = datatype.children[name]
  }
  for (var name in this.children) {
    sharedChildren[name] = this.children[name]
  }
  this.children = datatype.children = sharedChildren
  for (var name in sharedChildren) {
    sharedChildren[name].parents[this.id] = this
  }
}

Datatype.prototype.child = function(datatype){
  this.children[datatype.property] = datatype
  datatype.parents[this.id] = this
}

Datatype.prototype.schema = function(){
  var schema = {
    equivalencies: this.equivalencies(),
    instanceofs: this.instanceof(),
    subsetofs: this.subsetof(),
    array: this.isArray,
    properties: {}
  }
  var children = this.children
  for (var name in children) {
    var child = children[name]
    schema.properties[name] = {
      equivalencies: child.equivalencies(),
      instanceofs: child.instanceof(),
      subsetofs: child.subsetof(),
      array: child.isArray
    }
  }
  return schema
}

Datatype.prototype.canonical = function(){
  for (var id in this.aliases) {
    var alias = this.aliases[id]
    if (alias.isCanonical) return alias
  }
  for (var id in this.instanceofs) {
    var collection = this.instanceofs[id]
    if (collection.isCanonical) return collection
  }
  return this
}

Datatype.prototype.instanceof = function(){
  return Object.keys(this.instanceofs)
}

Datatype.prototype.subsetof = function(){
  return Object.keys(this.subsetofs)
}

Datatype.prototype.equivalencies = function(){
  return this.types().map(function(type){
    return type.split('.').reverse().join('/')
  })
}

Datatype.prototype.types = function(covered){
  covered = covered || {}
  var types = this.paths()
  covered[this.id] = true
  for (var id in this.aliases) {
    if (covered[id]) continue
    var alias = this.aliases[id]
    types = types.concat(alias.types(covered))
  }
  return types
}

/**
 * These are what can change this. Basically it's parent and all aliases.
 */

Datatype.prototype.affectiveTypes = function(covered){
  covered = covered || {}
  var types = this.types(covered)
  var covered = {}
  for (var name in this.children) {
    // if (covered[this.children[name].id]) continue
    var child = this.children[name]
    types = types.concat(child.affectiveTypes(covered))
  }
  return types
}

Datatype.prototype.affectivePaths = function(){
  var types = this.affectiveTypes().map(function(string){
    return string.split('.').reverse().join('/')
  })
  var x = {}
  types.forEach(function(type){
    x[type] = true
  })
  return Object.keys(x)
}

Datatype.prototype.fragments = function(){
  var fragments = {}
  for (var id in this.parents) {
    var parent = this.parents[id]
    if (parent.isUserland) break
    fragments[parent.property] = parent.fragments()
  }
  return fragments
}

Datatype.prototype.paths = function(){
  var fragments = this.fragments()
  var more = {}
  more[this.property] = fragments
  return Object.keys(flatten(more))
}

Datatype.prototype.get = function() {
  var canonical = this.canonical()
  return canonical.value
}

Datatype.prototype.set = function(value) {
  var canonical = this.canonical()
  canonical.isPrimitive = true
  return canonical.value = value
}

Datatype.prototype.registerProperty = function(property, type) {
  this.properties[property] = type
}

Datatype.prototype.toJSON = function() {
  return {
    property: this.property,
    value: this.value,
    equivalencies: this.equivalencies(),
    type: this.type,
    records: this.records,
    properties: this.properties,
    id: this.id,
    children: this.children
  }
}
